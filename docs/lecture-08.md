# 讲座#08:树索引
15-445/645数据库系统(春季2023)https://15445.courses.cs.cmu.edu/spring2023/卡内基梅隆大学查理加罗德
# 1 表索引
可以在数据库系统内部使用许多不同的数据结构，例如内部元数据、核心数据存储、临时数据结构或表索引。对于可能涉及范围扫描查询的表索引，散列表可能不是最佳选择，因为它本身就是无序的。

表索引是表列子集的副本，它被组织和/或排序，以便使用这些属性的子集进行有效访问。因此，DBMS可以在表索引上执行查找，以更快地找到某些元组，而不是执行顺序扫描。DBMS确保表和索引的内容在逻辑上始终保持同步。

在每个数据库要创建的索引数量之间存在权衡。虽然更多的索引使查找查询更快，但索引也使用存储并需要维护。另外，在保持它们同步方面还存在并发性问题。找出用于执行查询的最佳索引是DBMS的工作。

# 2 B+Tree
B+Tree是一种自平衡树数据结构，它保持数据排序，并允许在O(log(n))内进行搜索、顺序访问、插入和删除。它针对面向磁盘的DBMS进行了优化，这些DBMS需要读取/写入大量数据。

几乎所有支持保序索引的现代DBMS都使用B+树。有一种特定的数据结构称为b树，但人们也用这个术语泛指一类数据结构。原始B树和B+树的主要区别在于B树在所有节点中存储键和值，而B+树仅在叶节点中存储值。现代B+Tree实现结合了其他B-Tree变体的特性，例如Blink-Tree中使用的兄弟指针。

形式上，B+树是一棵M路搜索树(其中M表示一个节点可以拥有的子节点的最大数量)，具有以下属性:
- 它是完全平衡的(即每个叶节点都在相同的深度)。
- 除根节点外的每个内部节点至少为半满(M/2−1 <= num of keys <= M−1)。
- 每个有k个键的内部节点有k+1个非空子节点。

B+Tree中的每个节点都包含一个键/值对数组。

对于叶节点，键是从索引所基于的属性派生出来的。尽管根据B+Tree的定义，这不是必需的，但每个节点上的数组几乎总是按键排序的。获取叶节点值的两种方法是记录id和元组数据。记录id引用指向元组位置的指针，通常是主键。具有元组数据的叶节点在每个节点中存储元组的实际内容。

对于内部节点，值包含指向其他节点的指针，键可以被认为是路标。
它们引导树遍历，但不表示叶节点上的键(以及它们的值)。这意味着您可能在内部节点(作为引导柱)中有一个在叶节点上找不到的键。尽管必须注意的是，内部节点通常只拥有存在于叶节点中的那些键。

## 插入
要在B+Tree中插入新条目，必须遍历树并使用内部节点找出要将键插入的叶节点。
1. 找到正确的叶子L。
2. 按顺序将新的节点插入L
   - 如果L有足够的空间，则操作完成。
   - 否则将L拆分为两个节点L和L2。均匀地重新分配条目并向上复制中间键。在L的父节点中插入一个指向L2的表项。
3. 要拆分内部节点，请均匀地重新分配条目，但要向上推中间键。
删除
然而，在插入中，当树太满时，我们偶尔不得不拆分叶子，如果删除导致树少于一半满，我们必须合并以重新平衡树。
1. 找到正确的叶子L。
2. •如果L至少为半满，则操作结束。
•否则，你可以尝试重新分配，从兄弟姐妹那里借用。
•如果再分配失败，合并L和兄弟节点。
1. 如果发生合并，则必须删除父节点中指向L的条目。
选择条件
因为B+树是有序的，所以查找具有快速遍历并且不需要整个键。如果查询提供了搜索键的任何属性，DBMS可以使用B+Tree索引。这与散列索引不同，散列索引需要搜索键中的所有属性。
复制键
有两种方法可以在B+树中复制键。
第一种方法是附加记录id作为键的一部分。由于每个元组的记录ID是唯一的，这将确保所有键都是可识别的。
第二种方法是允许叶节点溢出到包含重复键的溢出节点中。
虽然不存储冗余信息，但这种方法维护和修改起来比较复杂。
聚集索引
表按照主键指定的排序顺序存储，作为堆组织存储或索引组织存储。
由于一些dbms总是使用聚集索引，因此如
果表没有显式索引，它们将自动将隐藏的行id设置为主键，但其他dbms根本不能使用它们。
堆集群
元组在堆的页面中按照集群索引指定的顺序排序。如果使用集群索引的属性访问元组，DBMS可以直接跳转到页面。
索引扫描页面排序
由于直接从未聚类索引中检索元组的效率很低，因此DBMS可以首先找出它需要的所有元组，然后根据它们的页id对它们进行排序。
# 3 B+树设计选择
3.1节点大小根据存储介质的不同，我们可以选择更大或更小的节点大小。例如，存储在硬盘驱动器上的节点的大小通常为兆字节，以减少查找数据所需的寻道次数，并将昂贵的磁盘读取分摊到大块数据上，而内存数据库可能使用小至512字节的页面大小，以便将整个页面放入CPU缓存中，并减少数据碎片。这种选择还取决于工作负载的类型，因为点查询希望页面尽可能小，以减少加载的不必要的额外信息，而大型顺序扫描可能希望页面更大，以减少需要执行的读取次数。
3.2合并阈值虽然B+树有一个关于在删除后合并未溢出节点的规则，但有时暂时违反该规则以减少删除操作的次数可能是有益的。例如，急于合并可能导致震荡，其中大量连续的删除和插入操作导致不断的拆分和合并。它还允许批处理合并，其中多个合并操作同时发生，减少了必须在树上使用昂贵的写锁存器的时间。
3.3可变长度键
目前我们只讨论了具有固定长度键的B+树。然而，我们也可能希望支持可变长度键，比如大键的一小部分子集导致大量空间浪费的情况。有几种方法可以做到这一点:我们可以不直接存储键，而是存储指向键的指针。由于必须为每个键跟踪指针的效率低下，因此在生产中使用这种方法的唯一地方是嵌入式设备，其微小的寄存器和缓存可能受益于这种空间节省2。可变长度节点我们也可以像平常一样存储键，并允许可变长度节点。这通常是不可行的，而且由于处理可变长度节点的内存管理开销很大，因此在很大程度上不被使用。
1. 我们可以将每个键的大小设置为最大键的大小，并填充所有较短的键，而不是改变键的大小。在大多数情况下，这是对内存的巨大浪费，所以您也不会看到有人使用它。
2. 键映射/间接几乎每个人都使用的方法是在单独的字典中用键-值对的索引替换键。这提供了显著的空间节省和潜在的快捷点查询(因为索引所指向的键值对与叶节点所指向的键值对完全相同)。由于字典索引值的大小很小，因此有足够的空间在索引旁边放置每个键的前缀，从而可能允许一些索引搜索和叶扫描甚至不必跟踪指针(如果前缀与搜索键完全不同)。
3.4节点内搜索
到达节点后，我们仍然需要在节点内进行搜索(从内部节点查找下一个节点，或者在叶节点中查找键值)。虽然这相对简单，但仍然需要考虑一些权衡:
1. 最简单的解决方案是扫描节点中的每个键，直到找到我们的键。一方面，我们不必担心键的排序，使插入和删除更快。另一方面，这种方法效率相对较低，每次搜索的复杂度为0 (n)。这可以使用SIMD(或等效)指令进行矢量化。
2. 一个更有效的搜索解决方案是保持每个节点排序，并使用二分搜索来查找键。这就像跳到节点的中间并根据键之间的比较向左或向右旋转一样简单。这种方法的搜索效率要高得多，因为这种方法每次搜索的复杂度只有O(ln(n))。然而，插入变得更加昂贵，因为我们必须维护每个节点的排序。
3. 最后，在某些情况下，我们可以利用插值来找到键。此方法利用存储在节点上的任何元数据(例如最大元素、最小元素、平均值等)，并使用它来生成键的大致位置。例如，如果我们在一个节点中寻找8，并且我们知道10是最大键，10−(n + 1)是最小键(其中n是每个节点中的键数)，那么我们知道从最大键开始搜索2个槽，因为在这种情况下，距离最大键的一个槽必须是9。尽管这是我们给出的最快的方法，但由于它对具有某些属性(如整数)和复杂性的键的适用性有限，因此只在学术数据库中看到这种方法。
# 4 优化
由于B+Tree的每个节点都存储在缓冲池中的一个页面中，因此每次我们加载一个新页面时都需要从缓冲池中取出它，这需要锁存和查找。要完全跳过这一步，我们可以将实际的原始指针存储在页id的位置(称为“swizzling”)，从而完全防止缓冲池获取。与手动获取整个树并手动放置指针不同，我们可以在正常遍历索引时简单地存储页面查找的结果指针。请注意，我们必须跟踪哪些指针被混淆了，并在它们指向的页面被解除固定并受害时将它们解混淆回页面id。
4.2批量插入当一个B+树最初构建时，必须以通常的方式插入每个键会导致不断的分割操作。由于我们已经为叶子提供了兄弟指针，如果我们构造一个叶节点的排序链表，然后使用每个叶节点的第一个键从下往上轻松地构建索引，那么初始数据插入的效率要高得多。请注意，根据我们的上下文，我们可能希望尽可能紧密地包装叶子以节省空间，或者在每个叶子中留下空间，以便在必要的拆分之前允许更多的插入。
大多数情况下，当我们在同一个节点上有键时，每个键的某些前缀会有部分重叠(因为在排序的B+树中，相似的键最终会紧挨着彼此)。与其将这个前缀作为每个键的一部分存储多次，我们可以简单地在节点的开头存储一次前缀，然后在每个槽中只包含每个键的唯一部分。
4.4重复数据删除在索引允许非唯一键的情况下，我们最终可能会得到叶节点一遍又一遍地包含相同的键，但附加了不同的值。对此的一种优化可以是只写一次键，然后用它的所有相关值跟随它。
在大多数情况下，内部节点中的键项只是用作路标，而不是用于其实际键值(因为即使索引中存在键，我们仍然需要搜索到底部以确保它没有被删除)。
我们可以利用这一点，只存储将探测正确路由到正确节点所需的最小前缀。